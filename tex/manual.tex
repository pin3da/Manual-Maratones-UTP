\documentclass[10pt,letterpaper,twocolumn,twosided]{article}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{listings}
\usepackage[usenames,dvipsnames]{color}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{hyperref}
\usepackage{color}
\usepackage{geometry}

\geometry{verbose,landscape,letterpaper,tmargin=2cm,bmargin=2cm,lmargin=2cm,rmargin=2cm}
\newcommand{\codigofuente}[1]{
\verbatiminput{#1}
\dotfill
}

\setlength{\columnsep}{0.25in}
\setlength{\columnseprule}{1px}

\begin{document}

\title{Resumen de algoritmos para maratones de programación}
\author{Manuel Felipe Pineda - Diego Alejandro Martínez}
\maketitle

\tableofcontents
\lstloadlanguages{C++,Java}

\newpage

%===============================================%
\section{Plantilla}
\codigofuente{../src/template.${EXT}}

%===============================================%
\section{Grafos}

\subsection{Depth First Search}

Es un algoritmo para recorrer o buscar en un grafo. Empieza visitando la raiz y luego explora 
a fondo cada rama antes de hacer el backtraing.\\
\\
Complejidad $O(|V|+|E|)$

\codigofuente{../src/dfs.${EXT}}

\subsection{Breadth First Search}

Es un algoritmo de búsqueda que empieza en la raíz y explora todos los nodos vecinos. Luego para cada
vecino repite el proceso hasta encontrar la meta.\\
Complejidad $O(|V|+|E|)$

\codigofuente{../src/bfs.${EXT}}

\subsection{Dijkstra}

Calcula la ruta más corta a todos los nodos desde un origen.\\
Todas las aristas deben ser NO negativas, en ese caso usar Bellman-ford.\\
Complejidad $O(E\ log V)$

\codigofuente{../src/dijkstra.${EXT}}


\subsection{Bellman-Ford}

The Bellman–Ford algorithm computes single-source shortest paths in a weighted digraph. For graphs with
only non-negative edge weights, the faster Dijkstra's algorithm also solves the problem. Thus, Bellman–Ford
is used primarily for graphs with negative edge weights. The algorithm is named after its developers, Richard
Bellman and Lester Ford, Jr.

If a graph contains a "negative cycle", i.e., a cycle whose edges sum to a negative value, then walks of
arbitrarily low weight can be constructed, i.e., there can be no shortest path. Bellman-Ford can detect
negative cycles and report their existence, but it cannot produce a correct answer if a negative cycle is
reachable from the source.

Para solucionar el longest path, simplemente se aplica bellman-ford con los pesos de los caminos negativos.

procedure BellmanFord(list vertices, list edges, vertex source)
   // This implementation takes in a graph, represented as lists of vertices
   // and edges, and modifies the vertices so that their distance and
   // predecessor attributes store the shortest paths.

   // Step 1: initialize graph
   for each vertex v in vertices:
       if v is source then v.distance := 0
       else v.distance := infinity
       v.predecessor := null

   // Step 2: relax edges repeatedly
   for i from 1 to size(vertices)-1:
       for each edge uv in edges: // uv is the edge from u to v
           u := uv.source
           v := uv.destination
           if u.distance + uv.weight < v.distance:
               v.distance := u.distance + uv.weight
               v.predecessor := u

   // Step 3: check for negative-weight cycles
   for each edge uv in edges:
       u := uv.source
       v := uv.destination
       if u.distance + uv.weight < v.distance:
           error "Graph contains a negative-weight cycle"


\subsection{Edge disjoint shortest paths}

Edge disjoint shortest pair algorithm is an algorithm in computer network routing. The algorithm 
is used for generating the shortest pair of edge disjoint paths between a given pair of vertices as follows:

Run the shortest pair algorithm for the given pair of vertices

Replace each edge of the shortest path (equivalent to two oppositely directed arcs) by a single arc directed 
towards the source vertex

Make the length of each of the above arcs negative

Run the shortest path algorithm (Note: the algorithm should accept negative costs)

Erase the overlapping edges of the two paths found, and reverse the direction of the remaining arcs on the 
first shortest path such that each arc on it is directed towards the sink vertex now. The desired pair of 
paths results.

\subsection{Floyd-Warshall}

\subsection{Johnson}

\subsection{Minimum Spanning Tree: Kruskal}

\subsection{Minimum Spanning Tree: Prim}

\subsection{Strongly Connected Components}

\subsection{Puntos de articulación}

\subsection{2-SAT}

\subsection{Maximum bipartite matching}

\subsection{Flujo Máximo}

\subsection{Lowest Common Ancestor: TarjanOLCA}

%===============================================%
\section{Matemáticas}

\subsection{Aritmética Modular}

Colección de códigos útiles para aritmética modular\\
\codigofuente{../src/euclidean.${EXT}}

\subsection{Mayor exponente de un primo que divide a n!}
\codigofuente{../src/pow_div.${EXT}}


\subsection{Potencia modular}

\subsection{Criba de Eratóstenes}



%===============================================%
\section{Geometría}

\subsection{Utilidades Geometría}

\subsection{Distancia mínima: Punto-Segmento}

\subsection{Distancia mínima: Punto-Recta}

\subsection{Determinar si un polígono es convexo}

\subsection{Determinar si un punto está dentro de un polígono convexo}

\subsection{Determinar si un punto está dentro de un polígono cualquiera}

\subsection{Intersección de dos rectas}

\subsection{Intersección de dos segmentos}

\subsection{Determinar si dos segmentos se intersectan o no}

\subsection{Centro del círculo que pasa por tres puntos}

\subsection{Par de puntos más cercanos}

\subsection{Par de puntos más alejados}

\subsection{Área de un polígono}

\subsection{Convexhull}

%===============================================%
\section{Strings}

\subsection{Knuth-Morris-Pratt KMP}

\subsection{Aho-Corasick}

\subsection{Suffix Array}

%===============================================%
\section{Teoría de Juegos}

%===============================================%
\section{Estructuras de Datos}

\subsection{Prefix Tree - Triee}

\subsection{Fenwick Tree}

\subsection{Interval Tree}

%===============================================%
\section{Hashing} %%http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx

\subsection{FNV Hash}

\subsection{JSW Hash}

%===============================================%
\section{Miseláneo}

\subsection {Bitwise operations}
Operaciones útiles con bits.

\codigofuente{../src/bitwise.${EXT}}







\end{document}
