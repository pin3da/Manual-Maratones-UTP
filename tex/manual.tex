\documentclass[10pt,letterpaper,twocolumn,twosided]{article}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{listings}
\usepackage[usenames,dvipsnames]{color}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{hyperref}
\usepackage{color}
\usepackage{geometry}

\geometry{verbose,landscape,letterpaper,tmargin=2cm,bmargin=2cm,lmargin=2cm,rmargin=2cm}
\newcommand{\codigofuente}[1]{
\verbatiminput{#1}
\dotfill
}

\setlength{\columnsep}{0.25in}
\setlength{\columnseprule}{1px}

\begin{document}

\title{Resumen de algoritmos para maratones de programación}
\author{Manuel Felipe Pineda - Diego Alejandro Martínez}
\maketitle

\tableofcontents
\lstloadlanguages{C++,Java}

\newpage

%===============================================%
\section{Plantilla}
\codigofuente{../src/template.${EXT}}

%===============================================%
\section{Grafos}

\subsection{Depth First Search}

Es un algoritmo para recorrer o buscar en un grafo. Empieza visitando la raiz y luego explora 
a fondo cada rama antes de hacer el backtraing.\\
\\
Complejidad $O(|V|+|E|)$

\codigofuente{../src/dfs.${EXT}}

\subsection{Breadth First Search}

Es un algoritmo de búsqueda que empieza en la raíz y explora todos los nodos vecinos. Luego para cada
vecino repite el proceso hasta encontrar la meta.\\
Complejidad $O(|V|+|E|)$

\codigofuente{../src/bfs.${EXT}}

\subsection{Dijkstra}

Calcula la ruta más corta a todos los nodos desde un origen.\\
Todas las aristas deben ser NO negativas, en ese caso usar Bellman-ford.\\
Complejidad $O(E\ log V)$

\codigofuente{../src/dijkstra.${EXT}}


\subsection{Bellman-Ford}

\subsection{Floyd-Warshall}

\subsection{Johnson}

\subsection{Minimum Spanning Tree: Kruskal}

\subsection{Minimum Spanning Tree: Prim}

\subsection{Strongly Connected Components}

\subsection{Puntos de articulación}

\subsection{2-SAT}

\subsection{Maximum bipartite matching}

\subsection{Flujo Máximo}

\subsection{Lowest Common Ancestor: TarjanOLCA}

%===============================================%
\section{Matemáticas}

\subsection{Aritmética Modular}

Colección de códigos útiles para aritmética modular\\
\codigofuente{../src/euclidean.${EXT}}

\subsection{Mayor exponente de un primo que divide a n!}
\codigofuente{../src/pow_div.${EXT}}


\subsection{Potencia modular}

\subsection{Criba de Eratóstenes}



%===============================================%
\section{Geometría}

\subsection{Utilidades Geometría}

\subsection{Distancia mínima: Punto-Segmento}

\subsection{Distancia mínima: Punto-Recta}

\subsection{Determinar si un polígono es convexo}

\subsection{Determinar si un punto está dentro de un polígono convexo}

\subsection{Determinar si un punto está dentro de un polígono cualquiera}

\subsection{Intersección de dos rectas}

\subsection{Intersección de dos segmentos}

\subsection{Determinar si dos segmentos se intersectan o no}

\subsection{Centro del círculo que pasa por tres puntos}

\subsection{Par de puntos más cercanos}

\subsection{Par de puntos más alejados}

\subsection{Área de un polígono}

\subsection{Convexhull}

%===============================================%
\section{Strings}

\subsection{Knuth-Morris-Pratt KMP}

\subsection{Aho-Corasick}

\subsection{Suffix Array}

%===============================================%
\section{Teoría de Juegos}

%===============================================%
\section{Estructuras de Datos}

\subsection{Prefix Tree - Triee}

\subsection{Fenwick Tree}

\subsection{Interval Tree}

%===============================================%
\section{Hashing} %%http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx

\subsection{FNV Hash}

\subsection{JSW Hash}

%===============================================%
\section{Miseláneo}

\subsection {Bitwise operations}
Operaciones útiles con bits.

\codigofuente{../src/bitwise.${EXT}}







\end{document}
